# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\app.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

// Importação de rotas
const authRoutes = require('./routes/auth.routes');
const userRoutes = require('./routes/user.routes');
const stockRoutes = require('./routes/stock.routes');
const portfolioRoutes = require('./routes/portfolio.routes');
const profileRoutes = require('./routes/profile.routes');
const recommendationRoutes = require('./routes/recommendations.routes');

// Inicialização do app
const app = express();

// Middleware de segurança
app.use(helmet());
app.use(cors());
app.use(express.json());

// Configuração do rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // limite de 100 requisições por windowMs
  standardHeaders: true,
  legacyHeaders: false,
});
app.use(limiter);

// Rotas
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/stocks', stockRoutes);
app.use('/api/portfolios', portfolioRoutes);
app.use('/api/profiles', profileRoutes);
app.use('/api/recommendations', recommendationRoutes);

// Middleware para tratamento de erros
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    status: 'error',
    message: 'Algo deu errado!',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// Endpoint padrão
app.get('/', (req, res) => {
  res.json({
    status: 'success',
    message: 'API do Sistema de Recomendação de Ações funcionando!'
  });
});

// Iniciar servidor
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

module.exports = app;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\config\database.js
const { Pool } = require('pg');
const dotenv = require('dotenv');

dotenv.config();

// Conexão com o Supabase (com URL encoding na senha)
const connectionString = process.env.DATABASE_URL;

const pool = new Pool({
  connectionString,
  ssl: process.env.NODE_ENV === 'production' 
    ? { rejectUnauthorized: false } 
    : false
});

// Teste inicial de conexão
pool.query('SELECT NOW()', (err, res) => {
  if (err) {
    console.error('❌ Erro ao conectar ao banco de dados:', err);
  } else {
    console.log('✅ Conectado com sucesso ao Supabase!', res.rows[0]);
  }
});

module.exports = {
  query: (text, params) => pool.query(text, params),
  pool
};


# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\config\supabase.js
const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

module.exports = supabase;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\controllers\authController.js
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const User = require('../models/userModel');

const JWT_SECRET = process.env.JWT_SECRET || 'seu_segredo_jwt';

class AuthController {
  static async register(req, res) {
    try {
      const { email, password, fullName } = req.body;
      
      // Validação básica
      if (!email || !password || !fullName) {
        return res.status(400).json({
          status: 'error',
          message: 'Todos os campos são obrigatórios'
        });
      }
      
      // Verificar se usuário já existe
      const existingUser = await User.findByEmail(email);
      
      if (existingUser) {
        return res.status(409).json({
          status: 'error',
          message: 'Este email já está em uso'
        });
      }
      
      // Criar novo usuário
      const newUser = await User.create({
        email,
        password,
        full_name: fullName
      });
      
      // Gerar token JWT
      const token = jwt.sign(
        { userId: newUser.id, email: newUser.email },
        JWT_SECRET,
        { expiresIn: '24h' }
      );
      
      // Retornar usuário e token
      res.status(201).json({
        status: 'success',
        message: 'Usuário criado com sucesso',
        data: {
          user: {
            id: newUser.id,
            email: newUser.email,
            name: newUser.full_name
          },
          token
        }
      });
    } catch (error) {
      console.error('Erro no registro:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
  
  static async login(req, res) {
    try {
      const { email, password } = req.body;
      
      if (!email || !password) {
        return res.status(400).json({
          status: 'error',
          message: 'Email e senha são obrigatórios'
        });
      }
      
      // Buscar usuário
      const user = await User.findByEmail(email);
      
      if (!user) {
        return res.status(404).json({
          status: 'error',
          message: 'Usuário não encontrado'
        });
      }
      
      // Verificar senha
      const passwordMatch = await bcrypt.compare(password, user.password);
      
      if (!passwordMatch) {
        return res.status(401).json({
          status: 'error',
          message: 'Senha incorreta'
        });
      }
      
      // Gerar token JWT
      const token = jwt.sign(
        { userId: user.id, email: user.email },
        JWT_SECRET,
        { expiresIn: '24h' }
      );
      
      // Retornar usuário e token
      res.json({
        status: 'success',
        message: 'Login realizado com sucesso',
        data: {
          user: {
            id: user.id,
            email: user.email,
            name: user.full_name
          },
          token
        }
      });
    } catch (error) {
      console.error('Erro no login:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
}

module.exports = AuthController;


# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\controllers\portfolioController.js
const Portfolio = require('../models/portfolioModel');
const Stock = require('../models/stockModel');

class PortfolioController {
  static async getAllStocks(req, res) {
    try {
      const { userId } = req.params;
      
      const portfolio = await Portfolio.getUserPortfolio(userId);
      
      res.json({
        status: 'success',
        data: portfolio
      });
    } catch (error) {
      console.error('Erro ao obter portfólio:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
  
  static async getPortfolioSummary(req, res) {
    try {
      const { userId } = req.params;
      
      const portfolio = await Portfolio.getUserPortfolio(userId);
      
      // Calcular métricas totais
      let totalInvested = 0;
      let totalCurrentValue = 0;
      let weightedRisk = 0;
      let weightedBeta = 0;
      
      for (const item of portfolio) {
        const stockValue = item.quantity * item.purchase_price;
        totalInvested += stockValue;
        
        // Obter preço atual (só estou usando o preço de compra como exemplo)
        const currentValue = item.quantity * (item.current_price || item.purchase_price);
        totalCurrentValue += currentValue;
        
        // Calcular risco ponderado
        weightedRisk += (stockValue / totalInvested) * item.risk_level;
        weightedBeta += (stockValue / totalInvested) * item.beta;
      }
      
      // Calcular rentabilidade total
      const profitLoss = totalCurrentValue - totalInvested;
      const profitPercentage = totalInvested > 0 
        ? (profitLoss / totalInvested) * 100 
        : 0;
      
      // Calcular distribuição por nível de risco
      const riskDistribution = portfolio.reduce((acc, item) => {
        const riskDesc = item.risk_description || `Nível ${item.risk_level}`;
        if (!acc[riskDesc]) {
          acc[riskDesc] = 0;
        }
        acc[riskDesc] += item.quantity * item.purchase_price;
        return acc;
      }, {});
      
      // Converter para percentagens
      for (const [risk, value] of Object.entries(riskDistribution)) {
        riskDistribution[risk] = (value / totalInvested) * 100;
      }
      
      res.json({
        status: 'success',
        data: {
          totalInvested,
          totalCurrentValue,
          profitLoss,
          profitPercentage,
          stockCount: portfolio.length,
          averageRiskLevel: weightedRisk,
          averageBeta: weightedBeta,
          riskDistribution
        }
      });
    } catch (error) {
      console.error('Erro ao obter resumo do portfólio:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
  
  static async addStock(req, res) {
    try {
      const { userId } = req.params;
      const { stockId, symbol, quantity, purchasePrice, purchaseDate } = req.body;
      
      if (!purchasePrice || !quantity || quantity <= 0) {
        return res.status(400).json({
          status: 'error',
          message: 'Dados inválidos. Verifique quantidade e preço de compra.'
        });
      }
      
      // Procurar pelo ID ou símbolo
      let stock;
      if (stockId) {
        stock = await Stock.getById(stockId);
      } else if (symbol) {
        stock = await Stock.getBySymbol(symbol);
      }
      
      if (!stock) {
        return res.status(404).json({
          status: 'error',
          message: 'Ação não encontrada'
        });
      }
      
      // Adicionar ao portfólio
      const result = await Portfolio.addStock(
        userId, 
        stock.id,
        quantity,
        purchasePrice,
        purchaseDate || new Date()
      );
      
      res.status(201).json({
        status: 'success',
        message: 'Ação adicionada ao portfólio',
        data: result
      });
    } catch (error) {
      console.error('Erro ao adicionar ação:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
  
  static async updateStock(req, res) {
    try {
      const { userId } = req.params;
      const { id } = req.params;
      const { quantity } = req.body;
      
      if (quantity === undefined) {
        return res.status(400).json({
          status: 'error',
          message: 'Quantidade não especificada'
        });
      }
      
      const result = await Portfolio.updateQuantity(userId, id, quantity);
      
      if (!result) {
        return res.status(404).json({
          status: 'error',
          message: 'Ação não encontrada no portfólio'
        });
      }
      
      res.json({
        status: 'success',
        message: 'Quantidade atualizada',
        data: result
      });
    } catch (error) {
      console.error('Erro ao atualizar ação:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
  
  static async removeStock(req, res) {
    try {
      const { userId } = req.params;
      const { id } = req.params;
      
      const result = await Portfolio.removeStock(userId, id);
      
      if (!result) {
        return res.status(404).json({
          status: 'error',
          message: 'Ação não encontrada no portfólio'
        });
      }
      
      res.json({
        status: 'success',
        message: 'Ação removida do portfólio'
      });
    } catch (error) {
      console.error('Erro ao remover ação:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
}

module.exports = PortfolioController;


# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\controllers\profileController.js
const InvestorProfile = require('../models/investorProfileModel');
const InvestorProfileService = require('../services/investorProfileService');

class ProfileController {
  static async getProfile(req, res) {
    try {
      const { userId } = req.params;
      
      const profile = await InvestorProfile.getByUserId(userId);
      
      if (!profile) {
        return res.status(404).json({
          status: 'error',
          message: 'Perfil de investidor não encontrado'
        });
      }
      
      res.json({
        status: 'success',
        data: profile
      });
    } catch (error) {
      console.error('Erro ao obter perfil:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
  
  static async saveProfile(req, res) {
    try {
      const { userId } = req.params;
      const { 
        risk_tolerance, 
        investment_horizon, 
        investment_experience, 
        monthly_income 
      } = req.body;
      
      // Validação básica
      if (risk_tolerance === undefined || investment_horizon === undefined || 
          investment_experience === undefined) {
        return res.status(400).json({
          status: 'error',
          message: 'Todos os campos obrigatórios devem ser fornecidos'
        });
      }
      
      // Calcular o tipo de perfil usando o serviço
      const profileService = new InvestorProfileService();
      const profile_type = profileService.calculateProfileType({
        risk_tolerance,
        investment_horizon,
        investment_experience
      });
      
      // Salvar ou atualizar o perfil
      const profile = await InvestorProfile.update(userId, {
        profile_type,
        risk_tolerance,
        investment_horizon,
        investment_experience,
        monthly_income
      });
      
      res.json({
        status: 'success',
        message: 'Perfil de investidor salvo com sucesso',
        data: profile
      });
    } catch (error) {
      console.error('Erro ao salvar perfil:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor'
      });
    }
  }
}

module.exports = ProfileController;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\controllers\recommendationController.js
const RecommendationService = require('../services/recommendationService');

class RecommendationController {
  static async getRecommendations(req, res) {
    try {
      const { userId } = req.params;
      
      const recommendationService = new RecommendationService();
      const recommendations = await recommendationService.getRecommendationsForUser(userId);
      
      res.json({
        status: 'success',
        data: recommendations
      });
    } catch (error) {
      console.error('Erro ao obter recomendações:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro interno no servidor',
        details: error.message
      });
    }
  }
}

module.exports = RecommendationController;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\controllers\stockController.js
const stockAnalysisService = require('../services/stockAnalysisService');

class StockController {
  // Obtém a lista de todas as ações
  async getAllStocks(req, res) {
    try {
      const filters = {
        riskCategory: req.query.risk_category,
        sector: req.query.sector
      };

      const limit = parseInt(req.query.limit) || 100;
      const offset = parseInt(req.query.offset) || 0;
      
      const stocks = await stockAnalysisService.getStocksWithFilters(filters, limit, offset);
      
      res.json({
        status: 'success',
        message: 'Ações obtidas com sucesso',
        data: stocks
      });
    } catch (error) {
      console.error('Erro ao obter ações:', error);
      res.status(500).json({
        status: 'error',
        message: 'Erro ao obter ações',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }
  
  // Obtém detalhes de uma ação específica
  async getStockBySymbol(req, res) {
    try {
      const symbol = req.params.symbol;
      
      // Obter análise da ação
      const stockAnalysis = await stockAnalysisService.analyzeStock(symbol);
      
      res.json({
        status: 'success',
        message: 'Ação obtida com sucesso',
        data: stockAnalysis
      });
    } catch (error) {
      console.error(`Erro ao obter ação ${req.params.symbol}:`, error);
      res.status(500).json({
        status: 'error',
        message: 'Erro ao obter ação',
        error: process.env.NODE_ENV === 'development' ? error.message : undefined
      });
    }
  }
}

module.exports = new StockController();

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\controllers\userController.js
const User = require('../models/userModel');

class UserController {
  static async getAllUsers(req, res) {
    try {
      const users = await User.findAll();
      res.json(users);
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  static async createUser(req, res) {
    try {
      const newUser = await User.create(req.body);
      res.status(201).json(newUser);
    } catch (error) {
      res.status(400).json({ error: error.message });
    }
  }


}

module.exports = UserController;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\middleware\authMiddleware.js
const jwt = require('jsonwebtoken');

const JWT_SECRET = process.env.JWT_SECRET || 'seu_segredo_jwt';

module.exports = (req, res, next) => {
  try {
    // Obter token do cabeçalho
    const authHeader = req.headers.authorization;
    
    if (!authHeader) {
      return res.status(401).json({
        status: 'error',
        message: 'Token de autenticação não fornecido'
      });
    }
    
    // Verificar formato do token
    const parts = authHeader.split(' ');
    
    if (parts.length !== 2) {
      return res.status(401).json({
        status: 'error',
        message: 'Erro no formato do token'
      });
    }
    
    const [scheme, token] = parts;
    
    if (!/^Bearer$/i.test(scheme)) {
      return res.status(401).json({
        status: 'error',
        message: 'Token mal formatado'
      });
    }
    
    // Verificar validade do token
    jwt.verify(token, JWT_SECRET, (err, decoded) => {
      if (err) {
        return res.status(401).json({
          status: 'error',
          message: 'Token inválido ou expirado'
        });
      }
      
      // Adicionar informações do usuário à requisição
      req.user = decoded;
      
      return next();
    });
  } catch (error) {
    return res.status(500).json({
      status: 'error',
      message: 'Erro interno na autenticação'
    });
  }
};

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\models\assetModel.js
const db = require('../config/database');

class Asset {
  static async getAll(type = null) {
    let query = 'SELECT * FROM assets';
    const params = [];
    
    if (type) {
      query += ' WHERE type = $1';
      params.push(type);
    }
    
    query += ' ORDER BY symbol';
    
    const result = await db.query(query, params);
    return result.rows;
  }
  
  static async getBySymbol(symbol) {
    const result = await db.query(
      'SELECT * FROM assets WHERE symbol = $1',
      [symbol]
    );
    
    return result.rows[0];
  }
  
  static async getById(id) {
    const result = await db.query(
      'SELECT * FROM assets WHERE id = $1',
      [id]
    );
    
    return result.rows[0];
  }
  
  static async getByRiskLevel(riskLevel, type = null) {
    let query = 'SELECT * FROM assets WHERE risk_level = $1';
    const params = [riskLevel];
    
    if (type) {
      query += ' AND type = $2';
      params.push(type);
    }
    
    const result = await db.query(query, params);
    return result.rows;
  }
  
  static async importFromRiskProfile(riskProfile) {
    // Função para importar dados do notebook
    const assets = [];
    
    for (const item of riskProfile) {
      try {
        const { ticker, risk_level, volatility, max_drawdown, beta, liquidity } = item;
        
        // Verificar se o ativo já existe
        const existingAsset = await this.getBySymbol(Crypto);
        
        if (existingAsset) {
          // Atualizar ativo existente
          const result = await db.query(
            `UPDATE assets 
             SET risk_level = $1, volatility = $2, max_drawdown = $3, beta = $4, liquidity = $5, updated_at = CURRENT_TIMESTAMP
             WHERE symbol = $6
             RETURNING *`,
            [risk_level, volatility, max_drawdown, beta, liquidity, ticker]
          );
          assets.push(result.rows[0]);
        } else {
          // Criar novo ativo
          const result = await db.query(
            `INSERT INTO assets (symbol, company_name, type, risk_level, volatility, max_drawdown, beta, liquidity)
             VALUES ($1, $1, 'ticker', $2, $3, $4, $5, $6)
             RETURNING *`,
            [ticker, risk_level, volatility, max_drawdown, beta, liquidity]
          );
          assets.push(result.rows[0]);
        }
      } catch (error) {
        console.error(`Erro ao importar ${item.ticker}:`, error);
      }
    }
    
    return assets;
  }
}

module.exports = Asset;


# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\models\investorProfileModel.js
const db = require('../config/database');

class InvestorProfile {
  static async getByUserId(userId) {
    const result = await db.query(
      'SELECT * FROM investor_profiles WHERE user_id = $1',
      [userId]
    );
    
    return result.rows[0];
  }
  
  static async create(profileData) {
    const { user_id, profile_type, risk_tolerance, investment_horizon, investment_experience, monthly_income } = profileData;
    
    const result = await db.query(
      `INSERT INTO investor_profiles 
       (user_id, profile_type, risk_tolerance, investment_horizon, investment_experience, monthly_income)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [user_id, profile_type, risk_tolerance, investment_horizon, investment_experience, monthly_income]
    );
    
    return result.rows[0];
  }
  
  static async update(userId, profileData) {
    const { profile_type, risk_tolerance, investment_horizon, investment_experience, monthly_income } = profileData;
    
    const result = await db.query(
      `UPDATE investor_profiles
       SET profile_type = $2, 
           risk_tolerance = $3, 
           investment_horizon = $4, 
           investment_experience = $5, 
           monthly_income = $6,
           updated_at = CURRENT_TIMESTAMP
       WHERE user_id = $1
       RETURNING *`,
      [userId, profile_type, risk_tolerance, investment_horizon, investment_experience, monthly_income]
    );
    
    // Se não existir, criar um novo
    if (result.rowCount === 0) {
      return this.create({
        user_id: userId,
        profile_type,
        risk_tolerance,
        investment_horizon,
        investment_experience,
        monthly_income
      });
    }
    
    return result.rows[0];
  }
}

module.exports = InvestorProfile;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\models\portfolioModel.js
const db = require('../config/database');

class Portfolio {
  static async getUserPortfolio(userId) {
    const result = await db.query(
      `SELECT p.id, p.quantity, p.purchase_price, p.purchase_date,
        s.id as stock_id, s.symbol, s.company_name, s.risk_level, 
        s.risk_category, s.volatility, s.max_drawdown, s.beta, s.liquidity
       FROM portfolios p
       JOIN stocks s ON p.stock_id = s.id
       WHERE p.user_id = $1`,
      [userId]
    );
    
    return result.rows;
  }
  
  static async addStock(userId, stockId, quantity, purchasePrice, purchaseDate) {
    // Verificar se já existe este ativo no portfólio
    const existingStock = await db.query(
      'SELECT id FROM portfolios WHERE user_id = $1 AND stock_id = $2',
      [userId, stockId]
    );
    
    if (existingStock.rows.length > 0) {
      // Atualizar quantidade
      const result = await db.query(
        `UPDATE portfolios 
         SET quantity = quantity + $3, 
             purchase_price = ((purchase_price * quantity) + ($3 * $4)) / (quantity + $3),
             updated_at = CURRENT_TIMESTAMP
         WHERE user_id = $1 AND stock_id = $2
         RETURNING *`,
        [userId, stockId, quantity, purchasePrice]
      );
      
      return result.rows[0];
    } else {
      // Adicionar nova ação
      const result = await db.query(
        `INSERT INTO portfolios (user_id, stock_id, quantity, purchase_price, purchase_date)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING *`,
        [userId, stockId, quantity, purchasePrice, purchaseDate]
      );
      
      return result.rows[0];
    }
  }
  
  static async removeStock(userId, portfolioId) {
    const result = await db.query(
      `DELETE FROM portfolios 
       WHERE id = $1 AND user_id = $2
       RETURNING *`,
      [portfolioId, userId]
    );
    
    return result.rows[0];
  }
  
  static async updateQuantity(userId, portfolioId, quantity) {
    if (quantity <= 0) {
      return this.removeStock(userId, portfolioId);
    }
    
    const result = await db.query(
      `UPDATE portfolios
       SET quantity = $3, updated_at = CURRENT_TIMESTAMP
       WHERE id = $1 AND user_id = $2
       RETURNING *`,
      [portfolioId, userId, quantity]
    );
    
    return result.rows[0];
  }
}

module.exports = Portfolio;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\models\stockModel.js
const db = require('../config/database');

class Stock {
  static async getAll() {
    const result = await db.query(
      'SELECT * FROM stocks ORDER BY symbol',
      []
    );
    
    return result.rows;
  }
  
  static async getBySymbol(symbol) {
    const result = await db.query(
      'SELECT * FROM stocks WHERE symbol = $1',
      [symbol]
    );
    
    return result.rows[0];
  }
  
  static async getById(id) {
    const result = await db.query(
      'SELECT * FROM stocks WHERE id = $1',
      [id]
    );
    
    return result.rows[0];
  }
  
  static async getByRiskLevel(riskLevel) {
    const result = await db.query(
      'SELECT * FROM stocks WHERE risk_level = $1',
      [riskLevel]
    );
    
    return result.rows;
  }
  
  static async importFromRiskProfile(classifiedStocks) {
    // Função para importar dados do notebook Python
    const stocks = [];
    
    for (const item of classifiedStocks) {
      try {
        const { ticker, volatility, max_drawdown, beta, liquidity, risk_level, risk_category } = item;
        
        // Verificar se a ação já existe
        const existingStock = await this.getBySymbol(ticker);
        
        if (existingStock) {
          // Atualizar ação existente
          const result = await db.query(
            `UPDATE stocks 
             SET risk_level = $1, risk_category = $2, volatility = $3, 
                 max_drawdown = $4, beta = $5, liquidity = $6, 
                 updated_at = CURRENT_TIMESTAMP
             WHERE symbol = $7
             RETURNING *`,
            [risk_level, risk_category, volatility, max_drawdown, 
             beta, liquidity, ticker]
          );
          stocks.push(result.rows[0]);
        } else {
          // Obter nome da empresa para a ação
          const companyName = ticker;
          
          // Criar nova ação
          const result = await db.query(
            `INSERT INTO stocks 
             (symbol, company_name, risk_level, risk_category, 
              volatility, max_drawdown, beta, liquidity)
             VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
             RETURNING *`,
            [ticker, company_name, risk_level, risk_category, 
             volatility, max_drawdown, beta, liquidity]
          );
          stocks.push(result.rows[0]);
        }
      } catch (error) {
        console.error(`Erro ao importar ${item.ticker}:`, error);
      }
    }
    
    return stocks;
  }
}

module.exports = Stock;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\models\userModel.js
const db = require('../config/database');
const bcrypt = require('bcrypt');

class User {
  static async create(userData) {
    const { email, password, full_name } = userData;
    
    // Hash da senha
    const hashedPassword = await bcrypt.hash(password, 10);
    
    const result = await db.query(
      `INSERT INTO users (email, password, full_name) 
       VALUES ($1, $2, $3) 
       RETURNING id, email, full_name, created_at`,
      [email, hashedPassword, full_name]
    );
    
    return result.rows[0];
  }
  
  static async findByEmail(email) {
    const result = await db.query(
      'SELECT * FROM users WHERE email = $1',
      [email]
    );
    
    return result.rows[0];
  }
  
  static async findById(id) {
    const result = await db.query(
      'SELECT id, email, full_name, created_at FROM users WHERE id = $1',
      [id]
    );
    
    return result.rows[0];
  }
}

module.exports = User;


# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\routes\auth.routes.js
const authController = require('../controllers/authController');
const express = require('express');
const router = express.Router();

router.post('/register', authController.register);
router.post('/login', authController.login);

module.exports = router;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\routes\portfolio.routes.js
const portfolioController = require('../controllers/portfolioController');
const express = require('express');
const router = express.Router();

// Rota para adicionar uma ação à carteira
router.post('/:userId/stocks', portfolioController.addStock);

// Rota para obter a carteira do usuário
router.get('/:userId', portfolioController.getPortfolioSummary);
router.get('/:userId/stocks', portfolioController.getAllStocks);

router.put('/:userId/stocks/:id', portfolioController.updateStock);

// Rota para remover uma ação da carteira
router.delete('/:userId/stocks/:id', portfolioController.removeStock);

module.exports = router;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\routes\profile.routes.js
const express = require('express');
const router = express.Router();
const profileController = require('../controllers/profileController');

// Rota para salvar o perfil do investidor
router.post('/:userId', profileController.saveProfile);

// Rota para obter o perfil do investidor
router.get('/:userId', profileController.getProfile);

module.exports = router;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\routes\recommendations.routes.js
const express = require('express');
const router = express.Router();
const recommendationController = require('../controllers/recommendationController');

// Rota para obter recomendações personalizadas para o usuário
router.get('/:userId', recommendationController.getRecommendations);

module.exports = router;


# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\routes\stock.routes.js
const express = require('express');
const router = express.Router();
const stockController = require('../controllers/stockController');

// Rota para obter todas as ações
router.get('/', stockController.getAllStocks);

// Rota para obter dados de uma ação específica
router.get('/:symbol', stockController.getStockBySymbol);

module.exports = router;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\routes\user.routes.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');

// Rota para registrar um novo usuário
router.post('/register', (req, res) => {
  res.json({ message: 'Registro de usuário (a ser implementado)' });
});

// Rota para login
router.post('/login', (req, res) => {
  res.json({ message: 'Login de usuário (a ser implementado)' });
});

module.exports = router;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\services\investorProfileService.js
class InvestorProfileService {
  calculateProfileType(answers) {
    const { risk_tolerance, investment_horizon, investment_experience } = answers;
    
    // Pontuação ponderada (baseada nos pesos dos critérios)
    const weights = {
      risk_tolerance: 0.5,      // 50% - Tolerância ao risco
      investment_horizon: 0.3,  // 30% - Horizonte de investimento
      investment_experience: 0.2 // 20% - Experiência com investimentos
    };
    
    // Normalizar valores para uma escala de 0-1 (considerando escala de 1-5)
    const normalized = {
      risk_tolerance: (risk_tolerance - 1) / 4,
      investment_horizon: (investment_horizon - 1) / 4,
      investment_experience: (investment_experience - 1) / 4
    };
    
    // Calcular pontuação final (0-1)
    const finalScore = 
      normalized.risk_tolerance * weights.risk_tolerance +
      normalized.investment_horizon * weights.investment_horizon +
      normalized.investment_experience * weights.investment_experience;
    
    // Classificar o perfil conforme o notebook
    if (finalScore < 0.2) {
      return 'Muito Conservador';
    } else if (finalScore < 0.4) {
      return 'Conservador';
    } else if (finalScore < 0.6) {
      return 'Moderado';
    } else if (finalScore < 0.8) {
      return 'Arrojado';
    } else {
      return 'Agressivo';
    }
  }
  
  getRecommendedRiskLevels(profileType) {
    // Recomendações baseadas no perfil conforme a função match_investor_profile do notebook
    switch (profileType) {
      case 'Muito Conservador':
        return {
          primary: [1], // Risco Muito Baixo
          secondary: [2]  // Risco Baixo
        };
      case 'Conservador':
        return {
          primary: [2], // Risco Baixo
          secondary: [1, 3]  // Risco Muito Baixo e Médio
        };
      case 'Moderado':
        return {
          primary: [3], // Risco Médio
          secondary: [2, 4]  // Risco Baixo e Alto
        };
      case 'Arrojado':
        return {
          primary: [4], // Risco Alto
          secondary: [3, 5]  // Risco Médio e Muito Alto
        };
      case 'Agressivo':
        return {
          primary: [5], // Risco Muito Alto
          secondary: [4]  // Risco Alto
        };
      default:
        return {
          primary: [3], // Risco Médio
          secondary: [2]  // Risco Baixo
        };
    }
  }
}

module.exports = InvestorProfileService;


# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\services\portfolioService.js
const db = require('../config/database');

class PortfolioService {
  /**
   * Adiciona uma ação ao portfólio do usuário
   * @param {Number} userId ID do usuário
   * @param {Object} stockData Dados da ação a ser adicionada
   * @returns {Object} Ação adicionada ao portfólio
   */
  async addStockToPortfolio(userId, stockData) {
    try {
      // Verificar se a ação existe
      const stockCheck = await db.query(
        'SELECT id FROM stocks WHERE symbol = $1',
        [stockData.symbol]
      );
      
      if (stockCheck.rows.length === 0) {
        throw new Error(`Ação com símbolo ${stockData.symbol} não encontrada`);
      }
      
      const stockId = stockCheck.rows[0].id;
      
      // Verificar se o usuário já tem essa ação no portfólio
      const existingStock = await db.query(
        'SELECT id FROM portfolios WHERE user_id = $1 AND stock_id = $2',
        [userId, stockId]
      );
      
      if (existingStock.rows.length > 0) {
        // Atualizar quantidade e preço médio
        const result = await db.query(
          `UPDATE portfolios
           SET quantity = quantity + $3,
               purchase_price = ((purchase_price * quantity) + ($4 * $3)) / (quantity + $3),
               updated_at = CURRENT_TIMESTAMP
           WHERE user_id = $1 AND stock_id = $2
           RETURNING *`,
          [userId, stockId, stockData.quantity, stockData.purchasePrice]
        );
        
        return result.rows[0];
      } else {
        // Adicionar nova ação ao portfólio
        const result = await db.query(
          `INSERT INTO portfolios
           (user_id, stock_id, quantity, purchase_price, purchase_date)
           VALUES ($1, $2, $3, $4, $5)
           RETURNING *`,
          [
            userId,
            stockId,
            stockData.quantity,
            stockData.purchasePrice,
            stockData.purchaseDate || new Date()
          ]
        );
        
        return result.rows[0];
      }
    } catch (error) {
      console.error('Erro ao adicionar ação ao portfólio:', error);
      throw error;
    }
  }
  
  /**
   * Remove uma ação do portfólio do usuário
   * @param {Number} userId ID do usuário
   * @param {Number} portfolioId ID do item do portfólio
   * @returns {Boolean} Sucesso da operação
   */
  async removeStockFromPortfolio(userId, portfolioId) {
    try {
      const result = await db.query(
        'DELETE FROM portfolios WHERE id = $1 AND user_id = $2 RETURNING id',
        [portfolioId, userId]
      );
      
      return result.rows.length > 0;
    } catch (error) {
      console.error('Erro ao remover ação do portfólio:', error);
      throw error;
    }
  }
  
  /**
   * Atualiza a quantidade de uma ação no portfólio
   * @param {Number} userId ID do usuário
   * @param {Number} portfolioId ID do item do portfólio
   * @param {Number} quantity Nova quantidade
   * @returns {Object} Item atualizado do portfólio
   */
  async updateStockQuantity(userId, portfolioId, quantity) {
    try {
      if (quantity <= 0) {
        return await this.removeStockFromPortfolio(userId, portfolioId);
      }
      
      const result = await db.query(
        `UPDATE portfolios
         SET quantity = $3, updated_at = CURRENT_TIMESTAMP
         WHERE id = $1 AND user_id = $2
         RETURNING *`,
        [portfolioId, userId, quantity]
      );
      
      if (result.rows.length === 0) {
        throw new Error('Item do portfólio não encontrado');
      }
      
      return result.rows[0];
    } catch (error) {
      console.error('Erro ao atualizar quantidade da ação:', error);
      throw error;
    }
  }
  
  /**
   * Obtém o portfólio completo do usuário
   * @param {Number} userId ID do usuário
   * @returns {Array} Lista de ações no portfólio
   */
  async getUserPortfolio(userId) {
    try {
      const result = await db.query(
        `SELECT p.id, p.quantity, p.purchase_price, p.purchase_date,
                s.symbol, s.company_name, s.sector, s.risk_category,
                sp.adj_close as current_price,
                sp.date as price_date,
                ((sp.adj_close - p.purchase_price) / p.purchase_price) * 100 as profit_percentage
         FROM portfolios p
         JOIN stocks s ON p.stock_id = s.id
         LEFT JOIN (
           SELECT DISTINCT ON (stock_id) stock_id, adj_close, date
           FROM stock_prices
           ORDER BY stock_id, date DESC
         ) sp ON s.id = sp.stock_id
         WHERE p.user_id = $1
         ORDER BY s.symbol ASC`,
        [userId]
      );
      
      // Calcular valores totais
      const portfolio = result.rows;
      
      let totalInvestment = 0;
      let totalCurrentValue = 0;
      
      portfolio.forEach(item => {
        const investmentValue = item.purchase_price * item.quantity;
        const currentValue = item.current_price * item.quantity;
        
        totalInvestment += investmentValue;
        totalCurrentValue += currentValue;
        
        // Adicionar valores calculados ao item
        item.investment_value = investmentValue;
        item.current_value = currentValue;
        item.profit_value = currentValue - investmentValue;
      });
      
      // Retornar portfólio com resumo
      return {
        stocks: portfolio,
        summary: {
          total_investment: totalInvestment,
          total_current_value: totalCurrentValue,
          total_profit_value: totalCurrentValue - totalInvestment,
          total_profit_percentage: totalInvestment > 0 
            ? ((totalCurrentValue - totalInvestment) / totalInvestment) * 100
            : 0
        }
      };
    } catch (error) {
      console.error('Erro ao obter portfólio do usuário:', error);
      throw error;
    }
  }
}

module.exports = new PortfolioService();

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\services\recommendationService.js
const Stock = require('../models/stockModel');
const InvestorProfile = require('../models/investorProfileModel');
const InvestorProfileService = require('./investorProfileService');
const maxPerCategory = parseInt(process.env.RECOMMENDATION_LIMIT) || 10;

class RecommendationService {
  async getRecommendationsForUser(userId) {
    try {
      // Obter o perfil do investidor
      const profile = await InvestorProfile.getByUserId(userId);
      
      if (!profile) {
        throw new Error('Perfil de investidor não encontrado');
      }
      
      // Obter recomendações baseadas no perfil
      const profileService = new InvestorProfileService();
      const riskLevels = profileService.getRecommendedRiskLevels(profile.profile_type);
      
      // Buscar ações recomendadas conforme os níveis de risco
      let recommendations = {};
      
      // Obter ações para cada nível de risco recomendado
      for (const [category, level] of Object.entries(riskLevels)) {
        if (Array.isArray(level)) {
          const stocksForCategory = [];
          for (const riskLevel of level) {
            const stocks = await Stock.getByRiskLevel(riskLevel);
            stocksForCategory.push(...stocks);
          }
          recommendations[category] = stocksForCategory;
        }
      }
      
      // Formatar e filtrar as recomendações
      const result = {
        profile_type: profile.profile_type,
        recommendations: {}
      };
      
      // Processar cada categoria
      for (const [category, stocks] of Object.entries(recommendations)) {
        if (stocks && stocks.length > 0) {
          result.recommendations[category] = this._formatRecommendations(
            stocks, 
            category === 'primary' ? 1.0 : 0.7
          );
        }
      }
      
      return result;
    } catch (error) {
      console.error('Erro ao obter recomendações:', error);
      throw error;
    }
  }
  
  _formatRecommendations(stocks, weight) {
    // Limitar a quantidade e adicionar peso de recomendação
    return stocks
      .slice(0, maxPerCategory) 
      .map(stock => ({
        id: stock.id,
        symbol: stock.symbol,
        company_name: stock.company_name,
        risk_level: stock.risk_level,
        risk_category: stock.risk_category,
        volatility: stock.volatility,
        beta: stock.beta,
        recommendation_weight: weight
      }));
  }
}

module.exports = RecommendationService;

# Arquivo: C:/Users/marco/OneDrive/Área de Trabalho/PI VI/backend/src\services\stockAnalysisService.js
const db = require('../config/database');

class StockAnalysisService {
  /**
   * Calcula informações de análise técnica para uma ação
   * @param {string} symbol Símbolo da ação
   * @returns {Object} Análise técnica da ação
   */
  async analyzeStock(symbol) {
    try {
      // Obter ID da ação
      const stockResult = await db.query('SELECT id FROM stocks WHERE symbol = $1', [symbol]);
      if (stockResult.rows.length === 0) {
        throw new Error(`Ação com símbolo ${symbol} não encontrada`);
      }
      
      const stockId = stockResult.rows[0].id;
      
      // Obter dados históricos dos últimos 252 dias úteis (1 ano)
      const pricesResult = await db.query(
        `SELECT date, adj_close, volume 
        FROM stock_prices 
         WHERE stock_id = $1 
         ORDER BY date DESC 
         LIMIT 252`,
        [stockId]
      );
      
      const prices = pricesResult.rows.reverse(); // Ordem cronológica
      
      if (prices.length < 20) {
        throw new Error('Dados históricos insuficientes para análise');
      }
      
      // Calcular média móvel de 20 dias
      const ma20 = this.calculateMovingAverage(prices, 20);
      
      // Calcular média móvel de 50 dias
      const ma50 = this.calculateMovingAverage(prices, 50);
      
      // Calcular RSI (Relative Strength Index)
      const rsi = this.calculateRSI(prices);
      
      // Calcular retorno diário médio
      const dailyReturns = this.calculateDailyReturns(prices);
      const avgDailyReturn = dailyReturns.reduce((sum, val) => sum + val, 0) / dailyReturns.length;
      
      // Calcular volatilidade (desvio padrão dos retornos diários)
      const volatility = this.calculateVolatility(dailyReturns);
      
      // Tendência recente (últimos 30 dias)
      const recentTrend = this.calculateTrend(prices.slice(-30));
      
      // Calcular preço atual e variação diária
      const latestPrice = prices[prices.length - 1].adj_close;
      const previousPrice = prices[prices.length - 2].adj_close;
      const dailyChange = ((latestPrice - previousPrice) / previousPrice) * 100;
      
      return {
        symbol,
        latestPrice,
        dailyChange,
        movingAverage20Days: ma20[ma20.length - 1],
        movingAverage50Days: ma50[ma50.length - 1],
        rsi: rsi[rsi.length - 1],
        volatility,
        avgDailyReturn,
        recentTrend,
        priceHistory: prices.map(p => ({
          date: sp.date,
          price: sp.adj_close,
          volume: sp.volume
        }))
      };
    } catch (error) {
      console.error(`Erro ao analisar ação ${symbol}:`, error);
      throw error;
    }
  }
  
  // Calcula a média móvel para um período específico
  calculateMovingAverage(prices, period) {
    const result = [];
    
    for (let i = 0; i < prices.length; i++) {
      if (i < period - 1) {
        result.push(null);
        continue;
      }
      
      let sum = 0;
      for (let j = i - period + 1; j <= i; j++) {
        sum += parseFloat(prices[j].adj_close);
      }
      
      result.push(sum / period);
    }
    
    return result;
  }
  
  // Calcula os retornos diários
  calculateDailyReturns(prices) {
    const returns = [];
    
    for (let i = 1; i < prices.length; i++) {
      const previousPrice = parseFloat(prices[i - 1].adj_close);
      const currentPrice = parseFloat(prices[i].adj_close);
      returns.push((currentPrice - previousPrice) / previousPrice);
    }
    
    return returns;
  }
  
  // Calcula a volatilidade (desvio padrão dos retornos)
  calculateVolatility(returns) {
    const mean = returns.reduce((sum, val) => sum + val, 0) / returns.length;
    const variance = returns.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / returns.length;
    return Math.sqrt(variance) * Math.sqrt(252); // Anualizado
  }
  
  // Calcula o RSI (Relative Strength Index)
  calculateRSI(prices, period = 14) {
    const changes = [];
    for (let i = 1; i < prices.length; i++) {
      changes.push(parseFloat(prices[i].adj_close) - parseFloat(prices[i - 1].adj_close));
    }
    
    const result = [];
    for (let i = 0; i < period - 1; i++) {
      result.push(null);
    }
    
    for (let i = period - 1; i < changes.length; i++) {
      let gains = 0;
      let losses = 0;
      
      for (let j = i - period + 1; j <= i; j++) {
        if (changes[j] > 0) {
          gains += changes[j];
        } else {
          losses -= changes[j];
        }
      }
      
      const avgGain = gains / period;
      const avgLoss = losses / period;
      
      if (avgLoss === 0) {
        result.push(100);
      } else {
        const rs = avgGain / avgLoss;
        result.push(100 - (100 / (1 + rs)));
      }
    }
    
    return result;
  }
  
  // Calcula a tendência recente
  calculateTrend(prices) {
    if (prices.length < 2) return 'Indefinida';
    
    const firstPrice = parseFloat(prices[0].adj_close);
    const lastPrice = parseFloat(prices[prices.length - 1].adj_close);
    
    const percentChange = ((lastPrice - firstPrice) / firstPrice) * 100;
    
    if (percentChange > 5) return 'Alta';
    if (percentChange < -5) return 'Baixa';
    return 'Lateral';
  }
  
  // Busca ações com base em filtros
  async getStocksWithFilters(filters = {}, limit = 100, offset = 0) {
    try {
      let query = `
        SELECT DISTINCT ON (s.symbol)
              s.symbol,
              s.company_name,
              s.sector,
              s.risk_category,
              s.dividend_yield,
              s.adj_close AS latest_price,
              s.date AS price_date,
              recent_prices.recent_history
        FROM stocks s
        LEFT JOIN LATERAL (
          SELECT json_agg(sub ORDER BY sub.date DESC) AS recent_history
          FROM (
            SELECT date, adj_close
            FROM stocks s2
            WHERE s2.symbol = s.symbol
            ORDER BY date DESC
            LIMIT 10
          ) sub
        ) recent_prices ON true
      `;
      
      const queryParams = [];
      let paramCount = 1;
      
      // Filtro por categoria de risco
      if (filters.riskCategory) {
        query += ` AND s.risk_category = $${paramCount}`;
        queryParams.push(filters.riskCategory);
        paramCount++;
      }
      
      // Filtro por setor
      if (filters.sector) {
        query += ` AND s.sector = $${paramCount}`;
        queryParams.push(filters.sector);
        paramCount++;
      }

      // Ordenação
      query += ` ORDER BY s.symbol ASC`;

      // Limite e offset
      query += ` LIMIT $${paramCount} OFFSET $${paramCount + 1}`;
      queryParams.push(limit, offset);
      paramCount += 2;

      const result = await db.query(query, queryParams);
      return result.rows;
    } catch (error) {
      console.error('Erro ao buscar ações com filtros:', error);
      throw error;
    }
  }
}

module.exports = new StockAnalysisService();

